"""
NumPy最重要的一个特点就是支持N维数组对象ndarray。ndarray对象与列表有相似之处，但也有着显著区别。
例如，构成列表的元素是“大杂烩”的，元素类型可以是字符串、字典、元组中的一种或多种，
但是NumPy数组中的元素则显得“纯洁”很多，它的元素类型必须“从一而终”，即只能是同一种数据类型。
"""
import numpy as np

# TODO 1.生成numpy数组
# TODO 1.1array方法
"""
array()方法可以接收任意数据类型（如列表、元组等）作为数据源。
比如说列表中的数据有整数，也有浮点数，NumPy会把所有数据都转换为浮点数，这是因为浮点数的精度更高。
通过类型转换，NumPy数组的数据源类型能保持统一。
"""

data1 = [1.0, 2, 900]
array1 = np.array(data1)  # 转换成array
print(array1.dtype)  # float64
array1.astype(np.int32)  # 用astype()方法显式指定被转换数组的数据类型

# TODO 1.2特定函数生成 arange(start,stop,step,dtype)
"""
arrange()根据start与stop指定的范围及step设定的步长，生成一个ndarray对象。
start为起始值，默认为0。stop为终止值。
取值区间是左闭右开的，即stop这个终止值是不包括在内的。
step为步长，如果不指定，默认值为1。
dtype指明返回ndarray的数据类型，如果没有提供，则会使用输入数据的类型。
"""
array2 = np.arange(0, 11, 1)
array3 = np.arange(11)
print(array2)
print(array3)

"""
arrange()方法的使用与Python的内置函数range()十分类似。
两者都能均匀地（evenly）等分区间，但range()仅可用于循环迭代。
它并不能直接输出由range()函数生成的数据元素，但可以通过for循环迭代取出这些数据，
这说明range()函数返回的是一个可迭代对象，可视作一个迭代器。
但np.arange返回的数组，不仅可以直接输出，还可以当作向量，参与到实际运算当中。
"""
array4 = range(11)
print(array4)  # range(0, 11)

# TODO 1.3 arange函数的'升级版' linspace函数
"""
当我们想在指定区间内生成指定个数的数组时，如果利用np.arange()来生成，则需要手动计算函数中所需的步长。
但实际上大可不必这么麻烦，np.linspace()函数就是为了解决这一问题而设计的。

使用np.linspace()在区间[1,10]中生成了20个等间隔的数据。
该方法的前两个参数分别指明生成元素的左右区间边界，
第三个参数确定上下限之间均匀等分的数据个数。
需要注意的是，np.arange()中数据区间是左闭右开的（即区间的最后一个数值是取不到的），
而np.linspace()生成的数据区间为闭区间。
当然我们也可以在该函数中指定endpoint=False，使生成数据区间变为左闭右开区间。
"""
array5 = np.linspace(1, 10, 10)
print(array5)  # [ 1.  2.  3.  4.  5.  6.  7.  8.  9. 10.]

# TODO 1.4 广播机制入门
"""
arr6是一个包含10个元素的向量[ 1  2  3  4  5  6  7  8  9 10]，
它和标量“1”实施相加操作，原本在向量“尺寸”上是不适配的。
之所以能成功实施，是因为利用了“广播”机制。
广播机制将这个标量“1”扩展为等长的向量[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]，
此时二者的维度是“门当户对”的，所以NumPy这才实施了对应的加法。
"""
array6 = np.arange(1, 11)
array7 = array5 + 1
print(array6)  # [ 1  2  3  4  5  6  7  8  9 10]
print(array7)  # [ 2  3  4  5  6  7  8  9 10 11]

# TODO 1.5 其他常用函数
"""
可以利用np.zeros()、np.ones()等函数，生成指定维度和填充固定数值的数组。
其中，np.zeros()函数生成的数组由0来填充，
np.ones()生成的数组由1来填充，它们通常用来对某些变量进行初始化。

在语法层面，我们简单解释一下np.zeros((3,4))的含义。
读者可能会对这个方法的使用有所疑惑，尺寸参数3和4为什么要用两层括号包裹呢？
实际上，应该将(3,4)整体视为一个匿名元组对象，
np.zeros((3,4))等价于np.zeros(shape=(3,4))，在shape参数处需要通过一个元组或列表来指明生成数组的尺寸。
"""
zeros = np.zeros((3, 3))
print(zeros)
"""
[[0. 0. 0.]
 [0. 0. 0.]
 [0. 0. 0.]]
"""
"""
如果用元组包裹描述数组尺寸的元素，而元组的外部轮廓就是两个圆括号，
那么在默认指定shape参数的情况下，这对圆括号就会和np.zeros()方法的外层括号相连，造成一定程度上的理解困扰，
所以我们推荐使用将方括号作为轮廓特征的列表来表示数组的尺寸。
"""
zeros1 = np.zeros([3, 3])
print(zeros1)

# 类似地，我们可以用np.ones()生成指定尺寸、元素全为1的数组
zeros2 = np.ones([1, 3], float)
print(zeros2)  # [[1. 1. 1.]]

"""
还有一种生成全0数组的方法是np.zeros_like()。
该方法的核心思想可概括为“借壳上市”，它会借用某个给定数组的类型、尺寸（即维度信息），
但其中的所有元素都被置换为0，这也是“zeros_like”名称的来源。

和np.ones()非常相似的一个操作是ones_like()。
它的功能是将数组中的元素都填充为1，数组的尺寸信息和数据类型来自一个给定数组。
"""

# reshape函数
array8 = np.arange(6)
print(array8)  # [0 1 2 3 4 5]
array8 = array8.reshape((2, 3))  # 将array8的尺寸重构为两行三列
array8 = array8.reshape([2, 3])  # 参数使用小括号和中括号都可以
print(array8)
"""
[[0 1 2]
 [3 4 5]]
"""